# **Как происходит накопление знаний**

Вопрос: *Накопление базы знаний в процессе разработки. В какой момент формируется база знаний о фичах, о том, как это должно
работать?*

Первый этап - порядок в задачах. Каждая задача решает какую-то бизнес-потребность. Соответственно рекомендуется придерживаться
структуры Эпик - Задача - Подзадача/Задача блокировщик.

Рекомендуется при создании задач добавлять в них следующую информацию:

- **why** – почему решено начать работу над данной задачей (информация от бизнеса, может быть ссылкой на эпик или статью в
Confluence с подробным описанием);
- **what** – что именно будет сделано;
- **dod** (definition of done) – список пунктов, соответствие которым свидетельствует о выполнении задачи.


За полнотой описания следит руководитель/тимлид/продакт.

Если мы делаем какие-то улучшения, допилки, правки - на это тоже лучше создавать задачи.

Каждый коммит рекомендуется сопровождать ссылкой на задачу, в рамках которой он был сделан. Мягкий сценарий - за этим следят
тимлиды/проджекты, жесткий вариант - внедрение прикоммитных хуков, чтобы коммит без ссылки на задачу завершался ошибкой. В
результате мы всегда знаем, что за код был залит, в рамках какой задачи, что хотели этим получить.

Следующий этап - создание документации. Подход к документации зависит от того, кто будет её использовать. Как правило, речь идёт о
внутренних пользователях и внешних.

## Два типа документации

### Для внутреннего использования

Команда ведёт базу знаний для себя:

- облегчить онбординг новых сотрудников;
- сохранить знания о своей работе;
- записать причины возникновения ошибок и пути их устранения.


Всё это экономит время команды. Что именно записывать, а что нет - решает сама команда.

Документация хранится в Confluence, описании задач, в комментариях кода:

- в задаче уже есть часть документации (why, what, dod) - важно, чтобы это описание было актуальным, если в процессе решили
что-то делать иначе, то в задаче эти изменения должны быть отражены;
- комментарии в коде, поясняющие что делает функция. Если разработчик рассматривал разные варианты решения какой-то
задачи, очень желательно, чтобы он в задаче или комментарии в коде записал, почему он в итоге выбрал то, что выбрал;
- всё, о чем новичку нужно знать для начала работы - лучше записать в документацию.

### Для внешнего использования

У команды есть внешний заказчик или пользователь:
- команда отправляет данные в таблицы баз данных, которыми пользуются другие команды;
- у команды есть API, к которому обращаются извне;
- команда предоставляет интерфейс, с которым работают внешние пользователи.

Во всех этих случаях необходима документация, прочитав которую, внешний пользователь сможет максимально самостоятельно
разобраться с продуктом команды, не обращаясь с вопросами к её членам.

Документация хранится в Confluence, на внешнем ресурсе (например, описание на GitHub), автоматически собирается из комментариев
в коде или с помощью инструментов типа Swagger.

Рекомендации:
- создание документации в этом сценарии лучше выносить в отдельный этап работы над продуктом:
  - разработка
  - тестирование
  - документирование. 
  Только после успешного прохождения всех трёх этапов задача считается выполненной;
- уведомлять внешних пользователей не только про изменения в продукте, но и про изменения в документации.


## Создатель документации

Вопрос: *Кто вносит информацию в базу и в какой момент цикла разработки? Актуализация базы знаний?*

Внутреннюю документацию может писать команда или обращаться за помощью к техническому писателю.

Внешнюю документацию лучше отдавать техническому писателю - это позволит придерживаться единого стиля, поддерживать качество
документации, встроить в процесс (разработка-тестирование-документирование) отдельного ответственного сотрудника.

Инициаторы обновления документации: проджект/продукт или технический писатель.

Инструменты техписателя для отслеживания изменений - командные демо, на них можно узнать, что изменилось и требует обновления.
Задачи от команды - в проекте ставится задача на создание/обновление документации и линкуется с задачей разработки, чтобы
технический писатель видел из why-what-dod, что произошло, и знал, к кому идти с вопросами.

## Что писать в документацию

Вопрос: *Как понять, что нужно вносить в базу знаний, а что не стоит?*

Что писать, а что нет:

- если о чем-то спросили больше трёх раз - лучше записать в документацию;
- если о какой-то особенности знает один-два человека и узнать об этом сложно - это нужно записать в базу знаний (в том числе
нужно стараться записывать старые вещи, легаси, которые были сделано давно и их редко трогают);
- если есть внешний пользователь продукта - о работе с продуктом нужно сделать документацию.

## Сохранение договоренностей и обсуждений

Вопрос: *Сохранение договорённостей и соглашений. В каком формате можно это делать, какие есть варианты? Как делают большие
ребята в других компаниям?*

Основные инструменты - это статья в Confluence. Самые распространённые форматы:

- **митинг ноутс** - команда/команды собираются и обсуждают задачи, в статье фиксируется кратко, что обсудили, принятые
решения, задачи, которые нужно выполнить. Сразу после обсуждения заводятся задачи в таск-трекере и линкуются с митинг
ноутс;
- **статья-обсуждение** - кто-то расписывает задачу (why, what, dod) в Confluence-статье, туда приходят все заинтересованные
(заказчики, исполнители) и обсуждают задачу. Статья редактируется по итогам обсуждения и в таск-трекере создаётся задача,
которая линкуется с данной статьей.

Данные документы хранятся в пространстве той команды, которая будет выполнять задачу. Для обсуждения рекомендуется структура:
- Внешние обсуждения:
  - Обсуждения с командой ...
    - Обсуждения с командой ... 2020
      - ДД-ММ-ГГГГ Тема обсуждения/название задачи


Вопрос: *Сопровождение совещаний документацией. Что надо фиксировать? Какие есть рекомендации по этому направлению?*

Зависит от темы, не обязательно фиксировать в документе каждое совещание. Если это ежедневный стендап, то документ не нужен.

Если обсуждается задача, собираются требования к разработке, принимаются какие-то решения - это лучше зафиксировать в митинг ноутс. Для этого в Confluence есть шаблон, в котором можно записать:

- дату обсуждения
- участников
- что хотели обсудить
- что обсудили (тезисы)
- какие решения приняли
- какие задачи и на кого нужно поставить


Если в совещании принимают участие разработчики, на которых должны быть назначены задачи, то рекомендуется чтобы они сами
ставили задачи - для повышения вовлеченности в обсуждение. Общее ведения митинг ноутс можно передавать разным людям, чтобы
все были сопричастны.

## Сопровождение роадмапа

Вопрос: Сопровождение роадмапа. Есть блок работ, который надо зафиналить. Подходит ли для этого confluence? Можно ли вести там
прогресс по задачам?

В Confluence можно с помощью макросов [выводить задачи из Jira](https://www.atlassian.com/ru/software/confluence/guides/expand-confluence/confluence-and-jira).

Но чтобы это было эффективно, задачи там должны быть тоже нормально организованы. Разбиты на эпики, быть в актуальном статусе.Тогда в Confluence на одной странице можно отслеживать весь прогресс.

Плюс для Confluenceа разработаны плагины, которые позволяют рисовать диаграммы Ганта, формировать календари с контрольными
точками и так далее. Большинство из них платные, но можно и бесплатными инструментами отслеживать статус по задачам.

## Автогенерируемая документация

Вопрос: *Автогенерируемая на основании кода документация. Есть ли опыт использования? Делает ли так кто-то из больших компаний?*

Автогенерацию документации делают и очень многие. Всё что касается документации по коду, почти всегда автогенерируется или
просто хранится в коде. Инструментов большое количество, у нас тоже есть хакатоновский опыт создания подобной документации. Но
это документация от разработчиков - разработчикам. Скорее внутренний продукт.

Если говорить про API, то тут есть Cваггер, который позволяет не только создавать документацию к запросам и ответам, но и
валидировать изменения в API. Можно автоматизировать проверку запросов/ответов при каждом коммите, чтобы разработчики не
забывали обновлять Cваггер и держать его в актуальном состоянии. 

Но можно и без Cваггера, многие делают документацию к API руками, если она меняется не часто, то зачастую это эффективнее и быстрее, потому что такую документацию может поддерживать технический писатель. Документацию в Cваггере тоже может, но как правило, она всё такие лежит на плечах разработчиков, потому что
флоу строится именно так: внес изменения в код - поправил схемы Cваггера - закоммитил изменения в репозиторий. И ждать тут
технического писателя не выгодно.